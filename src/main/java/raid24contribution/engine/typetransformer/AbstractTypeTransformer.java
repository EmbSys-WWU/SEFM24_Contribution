package raid24contribution.engine.typetransformer;

import java.io.IOException;
import java.util.LinkedList;
import java.util.List;
import javax.xml.parsers.ParserConfigurationException;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.w3c.dom.Document;
import org.xml.sax.SAXException;
import raid24contribution.engine.Engine;
import raid24contribution.engine.Environment;
import raid24contribution.engine.util.IOUtil;
import raid24contribution.engine.util.Pair;
import raid24contribution.sc_model.SCClass;
import raid24contribution.sc_model.expressions.Expression;
import raid24contribution.sc_model.variables.SCKnownType;

public class AbstractTypeTransformer implements KnownTypeTransformer {
    
    private static Logger logger = LogManager.getLogger(AbstractTypeTransformer.class.getName());
    
    protected String name = null;
    protected String impl = null;
    
    @Override
    public String getImplementation() {
        return this.impl;
    }
    
    
    @Override
    public void setImplementation(String file) {
        this.impl = file;
    }
    
    
    public Environment createGenericType(Environment e, Pair<String, String> replacements[]) {
        Environment temp = null;
        if (this.impl != null) {
            // in this case we have to read the implementation
            try {
                // Create temporary copy and parse
                IOUtil.removeFileIfExist(this.impl + ".tmp");
                IOUtil.createCopy(this.impl, this.impl + ".tmp");
                for (Pair<String, String> replacement : replacements) {
                    IOUtil.replaceAllInFile(this.impl + ".tmp", replacement.getFirst(), replacement.getSecond());
                }
                Document doc = IOUtil.readXML(this.impl + ".tmp");
                
                // Parsing the implementation file
                temp = Engine.parseImplementation(doc);
                
            } catch (SAXException exc) {
                exc.printStackTrace();
            } catch (IOException exc) {
                exc.printStackTrace();
            } catch (ParserConfigurationException exc) {
                exc.printStackTrace();
            } finally {
                IOUtil.removeFileIfExist(this.impl + ".tmp");
            }
        }
        return temp;
    }
    
    
    @Override
    public void createType(Environment e) {
        // check if it has been created yet
        if (!existsType(this.name, e)) {
            // there are two possibilities: either the type has a dedicated
            // implementation
            if (this.impl != null) {
                // in this case we have to read the implementation
                try {
                    Document doc = IOUtil.readXML(this.impl);
                    // Parsing the implementation file
                    Environment temp = Engine.parseImplementation(doc);
                    // Integrating the newly parsed environment into the already
                    // existing
                    e.integrate(temp);
                    
                } catch (SAXException exc) {
                    exc.printStackTrace();
                } catch (IOException exc) {
                    exc.printStackTrace();
                } catch (ParserConfigurationException exc) {
                    exc.printStackTrace();
                }
            }
            // or it has no dedicated implementation
            // we have to handle this case in the specific knownType classes.
        }
    }
    
    /**
     * Usually types generated by type transformers are used as known types. Overwrite this method if
     * necessary.
     *
     * @param name
     * @param e
     * @return
     */
    public boolean existsType(String name, Environment e) {
        return e.getKnownTypes().containsKey(name);
    }
    
    @Override
    public SCKnownType createInstance(String instName, Environment e, boolean stat, boolean cons,
            List<String> other_mods) {
        SCClass type = e.getKnownTypes().get(this.name);
        SCKnownType kt = null;
        if (type != null) {
            kt = new SCKnownType(instName, type, e.getCurrentClass(), null, stat, cons, other_mods,
                    e.getLastInitializer());
        } else {
            logger.error("Configuration error: type {} cannot be instantiated.", this.name);
        }
        return kt;
    }
    
    @Override
    public SCKnownType initiateInstance(String instName, List<Expression> params, Environment e, boolean stat,
            boolean cons, List<String> other_mods) {
        SCClass type = e.getKnownTypes().get(this.name);
        SCKnownType kt = null;
        if (type != null) {
            if (e.getKnownTypes().get(this.name).getConstructor() != null
                    && e.getKnownTypes().get(this.name).getConstructor().getParameters().size() != params.size()) {
                logger.error("ERROR: " + this + ": not the right number of parameters to initiate " + instName
                        + ". Expected was " + e.getKnownTypes().get(this.name).getConstructor().getParameters().size()
                        + " parameters but got " + params.size() + ".");
                return null;
            } else {
                kt = new SCKnownType(instName, type, e.getCurrentClass(), new LinkedList<>(), stat, cons,
                        other_mods, e.getLastInitializer());
            }
        } else {
            logger.error("Configuration error: cannot initiate an instance of type {}.", this.name);
        }
        return kt;
    }
    
}
